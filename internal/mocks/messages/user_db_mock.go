// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package messages

//go:generate minimock -i github.com/Svoevolin/workshop_1_bot/internal/model/messages.UserDB -o user_db_mock.go -n UserDBMock -p messages

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// UserDBMock implements messages.UserDB
type UserDBMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcChangeDefaultCurrency          func(ctx context.Context, userID int64, currency string) (err error)
	inspectFuncChangeDefaultCurrency   func(ctx context.Context, userID int64, currency string)
	afterChangeDefaultCurrencyCounter  uint64
	beforeChangeDefaultCurrencyCounter uint64
	ChangeDefaultCurrencyMock          mUserDBMockChangeDefaultCurrency

	funcGetDefaultCurrency          func(ctx context.Context, userID int64) (s1 string, err error)
	inspectFuncGetDefaultCurrency   func(ctx context.Context, userID int64)
	afterGetDefaultCurrencyCounter  uint64
	beforeGetDefaultCurrencyCounter uint64
	GetDefaultCurrencyMock          mUserDBMockGetDefaultCurrency

	funcUserExists          func(ctx context.Context, userID int64) (b1 bool)
	inspectFuncUserExists   func(ctx context.Context, userID int64)
	afterUserExistsCounter  uint64
	beforeUserExistsCounter uint64
	UserExistsMock          mUserDBMockUserExists
}

// NewUserDBMock returns a mock for messages.UserDB
func NewUserDBMock(t minimock.Tester) *UserDBMock {
	m := &UserDBMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ChangeDefaultCurrencyMock = mUserDBMockChangeDefaultCurrency{mock: m}
	m.ChangeDefaultCurrencyMock.callArgs = []*UserDBMockChangeDefaultCurrencyParams{}

	m.GetDefaultCurrencyMock = mUserDBMockGetDefaultCurrency{mock: m}
	m.GetDefaultCurrencyMock.callArgs = []*UserDBMockGetDefaultCurrencyParams{}

	m.UserExistsMock = mUserDBMockUserExists{mock: m}
	m.UserExistsMock.callArgs = []*UserDBMockUserExistsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserDBMockChangeDefaultCurrency struct {
	mock               *UserDBMock
	defaultExpectation *UserDBMockChangeDefaultCurrencyExpectation
	expectations       []*UserDBMockChangeDefaultCurrencyExpectation

	callArgs []*UserDBMockChangeDefaultCurrencyParams
	mutex    sync.RWMutex
}

// UserDBMockChangeDefaultCurrencyExpectation specifies expectation struct of the UserDB.ChangeDefaultCurrency
type UserDBMockChangeDefaultCurrencyExpectation struct {
	mock    *UserDBMock
	params  *UserDBMockChangeDefaultCurrencyParams
	results *UserDBMockChangeDefaultCurrencyResults
	Counter uint64
}

// UserDBMockChangeDefaultCurrencyParams contains parameters of the UserDB.ChangeDefaultCurrency
type UserDBMockChangeDefaultCurrencyParams struct {
	ctx      context.Context
	userID   int64
	currency string
}

// UserDBMockChangeDefaultCurrencyResults contains results of the UserDB.ChangeDefaultCurrency
type UserDBMockChangeDefaultCurrencyResults struct {
	err error
}

// Expect sets up expected params for UserDB.ChangeDefaultCurrency
func (mmChangeDefaultCurrency *mUserDBMockChangeDefaultCurrency) Expect(ctx context.Context, userID int64, currency string) *mUserDBMockChangeDefaultCurrency {
	if mmChangeDefaultCurrency.mock.funcChangeDefaultCurrency != nil {
		mmChangeDefaultCurrency.mock.t.Fatalf("UserDBMock.ChangeDefaultCurrency mock is already set by Set")
	}

	if mmChangeDefaultCurrency.defaultExpectation == nil {
		mmChangeDefaultCurrency.defaultExpectation = &UserDBMockChangeDefaultCurrencyExpectation{}
	}

	mmChangeDefaultCurrency.defaultExpectation.params = &UserDBMockChangeDefaultCurrencyParams{ctx, userID, currency}
	for _, e := range mmChangeDefaultCurrency.expectations {
		if minimock.Equal(e.params, mmChangeDefaultCurrency.defaultExpectation.params) {
			mmChangeDefaultCurrency.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmChangeDefaultCurrency.defaultExpectation.params)
		}
	}

	return mmChangeDefaultCurrency
}

// Inspect accepts an inspector function that has same arguments as the UserDB.ChangeDefaultCurrency
func (mmChangeDefaultCurrency *mUserDBMockChangeDefaultCurrency) Inspect(f func(ctx context.Context, userID int64, currency string)) *mUserDBMockChangeDefaultCurrency {
	if mmChangeDefaultCurrency.mock.inspectFuncChangeDefaultCurrency != nil {
		mmChangeDefaultCurrency.mock.t.Fatalf("Inspect function is already set for UserDBMock.ChangeDefaultCurrency")
	}

	mmChangeDefaultCurrency.mock.inspectFuncChangeDefaultCurrency = f

	return mmChangeDefaultCurrency
}

// Return sets up results that will be returned by UserDB.ChangeDefaultCurrency
func (mmChangeDefaultCurrency *mUserDBMockChangeDefaultCurrency) Return(err error) *UserDBMock {
	if mmChangeDefaultCurrency.mock.funcChangeDefaultCurrency != nil {
		mmChangeDefaultCurrency.mock.t.Fatalf("UserDBMock.ChangeDefaultCurrency mock is already set by Set")
	}

	if mmChangeDefaultCurrency.defaultExpectation == nil {
		mmChangeDefaultCurrency.defaultExpectation = &UserDBMockChangeDefaultCurrencyExpectation{mock: mmChangeDefaultCurrency.mock}
	}
	mmChangeDefaultCurrency.defaultExpectation.results = &UserDBMockChangeDefaultCurrencyResults{err}
	return mmChangeDefaultCurrency.mock
}

// Set uses given function f to mock the UserDB.ChangeDefaultCurrency method
func (mmChangeDefaultCurrency *mUserDBMockChangeDefaultCurrency) Set(f func(ctx context.Context, userID int64, currency string) (err error)) *UserDBMock {
	if mmChangeDefaultCurrency.defaultExpectation != nil {
		mmChangeDefaultCurrency.mock.t.Fatalf("Default expectation is already set for the UserDB.ChangeDefaultCurrency method")
	}

	if len(mmChangeDefaultCurrency.expectations) > 0 {
		mmChangeDefaultCurrency.mock.t.Fatalf("Some expectations are already set for the UserDB.ChangeDefaultCurrency method")
	}

	mmChangeDefaultCurrency.mock.funcChangeDefaultCurrency = f
	return mmChangeDefaultCurrency.mock
}

// When sets expectation for the UserDB.ChangeDefaultCurrency which will trigger the result defined by the following
// Then helper
func (mmChangeDefaultCurrency *mUserDBMockChangeDefaultCurrency) When(ctx context.Context, userID int64, currency string) *UserDBMockChangeDefaultCurrencyExpectation {
	if mmChangeDefaultCurrency.mock.funcChangeDefaultCurrency != nil {
		mmChangeDefaultCurrency.mock.t.Fatalf("UserDBMock.ChangeDefaultCurrency mock is already set by Set")
	}

	expectation := &UserDBMockChangeDefaultCurrencyExpectation{
		mock:   mmChangeDefaultCurrency.mock,
		params: &UserDBMockChangeDefaultCurrencyParams{ctx, userID, currency},
	}
	mmChangeDefaultCurrency.expectations = append(mmChangeDefaultCurrency.expectations, expectation)
	return expectation
}

// Then sets up UserDB.ChangeDefaultCurrency return parameters for the expectation previously defined by the When method
func (e *UserDBMockChangeDefaultCurrencyExpectation) Then(err error) *UserDBMock {
	e.results = &UserDBMockChangeDefaultCurrencyResults{err}
	return e.mock
}

// ChangeDefaultCurrency implements messages.UserDB
func (mmChangeDefaultCurrency *UserDBMock) ChangeDefaultCurrency(ctx context.Context, userID int64, currency string) (err error) {
	mm_atomic.AddUint64(&mmChangeDefaultCurrency.beforeChangeDefaultCurrencyCounter, 1)
	defer mm_atomic.AddUint64(&mmChangeDefaultCurrency.afterChangeDefaultCurrencyCounter, 1)

	if mmChangeDefaultCurrency.inspectFuncChangeDefaultCurrency != nil {
		mmChangeDefaultCurrency.inspectFuncChangeDefaultCurrency(ctx, userID, currency)
	}

	mm_params := UserDBMockChangeDefaultCurrencyParams{ctx, userID, currency}

	// Record call args
	mmChangeDefaultCurrency.ChangeDefaultCurrencyMock.mutex.Lock()
	mmChangeDefaultCurrency.ChangeDefaultCurrencyMock.callArgs = append(mmChangeDefaultCurrency.ChangeDefaultCurrencyMock.callArgs, &mm_params)
	mmChangeDefaultCurrency.ChangeDefaultCurrencyMock.mutex.Unlock()

	for _, e := range mmChangeDefaultCurrency.ChangeDefaultCurrencyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmChangeDefaultCurrency.ChangeDefaultCurrencyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChangeDefaultCurrency.ChangeDefaultCurrencyMock.defaultExpectation.Counter, 1)
		mm_want := mmChangeDefaultCurrency.ChangeDefaultCurrencyMock.defaultExpectation.params
		mm_got := UserDBMockChangeDefaultCurrencyParams{ctx, userID, currency}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmChangeDefaultCurrency.t.Errorf("UserDBMock.ChangeDefaultCurrency got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmChangeDefaultCurrency.ChangeDefaultCurrencyMock.defaultExpectation.results
		if mm_results == nil {
			mmChangeDefaultCurrency.t.Fatal("No results are set for the UserDBMock.ChangeDefaultCurrency")
		}
		return (*mm_results).err
	}
	if mmChangeDefaultCurrency.funcChangeDefaultCurrency != nil {
		return mmChangeDefaultCurrency.funcChangeDefaultCurrency(ctx, userID, currency)
	}
	mmChangeDefaultCurrency.t.Fatalf("Unexpected call to UserDBMock.ChangeDefaultCurrency. %v %v %v", ctx, userID, currency)
	return
}

// ChangeDefaultCurrencyAfterCounter returns a count of finished UserDBMock.ChangeDefaultCurrency invocations
func (mmChangeDefaultCurrency *UserDBMock) ChangeDefaultCurrencyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangeDefaultCurrency.afterChangeDefaultCurrencyCounter)
}

// ChangeDefaultCurrencyBeforeCounter returns a count of UserDBMock.ChangeDefaultCurrency invocations
func (mmChangeDefaultCurrency *UserDBMock) ChangeDefaultCurrencyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChangeDefaultCurrency.beforeChangeDefaultCurrencyCounter)
}

// Calls returns a list of arguments used in each call to UserDBMock.ChangeDefaultCurrency.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmChangeDefaultCurrency *mUserDBMockChangeDefaultCurrency) Calls() []*UserDBMockChangeDefaultCurrencyParams {
	mmChangeDefaultCurrency.mutex.RLock()

	argCopy := make([]*UserDBMockChangeDefaultCurrencyParams, len(mmChangeDefaultCurrency.callArgs))
	copy(argCopy, mmChangeDefaultCurrency.callArgs)

	mmChangeDefaultCurrency.mutex.RUnlock()

	return argCopy
}

// MinimockChangeDefaultCurrencyDone returns true if the count of the ChangeDefaultCurrency invocations corresponds
// the number of defined expectations
func (m *UserDBMock) MinimockChangeDefaultCurrencyDone() bool {
	for _, e := range m.ChangeDefaultCurrencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChangeDefaultCurrencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChangeDefaultCurrencyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChangeDefaultCurrency != nil && mm_atomic.LoadUint64(&m.afterChangeDefaultCurrencyCounter) < 1 {
		return false
	}
	return true
}

// MinimockChangeDefaultCurrencyInspect logs each unmet expectation
func (m *UserDBMock) MinimockChangeDefaultCurrencyInspect() {
	for _, e := range m.ChangeDefaultCurrencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserDBMock.ChangeDefaultCurrency with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChangeDefaultCurrencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChangeDefaultCurrencyCounter) < 1 {
		if m.ChangeDefaultCurrencyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserDBMock.ChangeDefaultCurrency")
		} else {
			m.t.Errorf("Expected call to UserDBMock.ChangeDefaultCurrency with params: %#v", *m.ChangeDefaultCurrencyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChangeDefaultCurrency != nil && mm_atomic.LoadUint64(&m.afterChangeDefaultCurrencyCounter) < 1 {
		m.t.Error("Expected call to UserDBMock.ChangeDefaultCurrency")
	}
}

type mUserDBMockGetDefaultCurrency struct {
	mock               *UserDBMock
	defaultExpectation *UserDBMockGetDefaultCurrencyExpectation
	expectations       []*UserDBMockGetDefaultCurrencyExpectation

	callArgs []*UserDBMockGetDefaultCurrencyParams
	mutex    sync.RWMutex
}

// UserDBMockGetDefaultCurrencyExpectation specifies expectation struct of the UserDB.GetDefaultCurrency
type UserDBMockGetDefaultCurrencyExpectation struct {
	mock    *UserDBMock
	params  *UserDBMockGetDefaultCurrencyParams
	results *UserDBMockGetDefaultCurrencyResults
	Counter uint64
}

// UserDBMockGetDefaultCurrencyParams contains parameters of the UserDB.GetDefaultCurrency
type UserDBMockGetDefaultCurrencyParams struct {
	ctx    context.Context
	userID int64
}

// UserDBMockGetDefaultCurrencyResults contains results of the UserDB.GetDefaultCurrency
type UserDBMockGetDefaultCurrencyResults struct {
	s1  string
	err error
}

// Expect sets up expected params for UserDB.GetDefaultCurrency
func (mmGetDefaultCurrency *mUserDBMockGetDefaultCurrency) Expect(ctx context.Context, userID int64) *mUserDBMockGetDefaultCurrency {
	if mmGetDefaultCurrency.mock.funcGetDefaultCurrency != nil {
		mmGetDefaultCurrency.mock.t.Fatalf("UserDBMock.GetDefaultCurrency mock is already set by Set")
	}

	if mmGetDefaultCurrency.defaultExpectation == nil {
		mmGetDefaultCurrency.defaultExpectation = &UserDBMockGetDefaultCurrencyExpectation{}
	}

	mmGetDefaultCurrency.defaultExpectation.params = &UserDBMockGetDefaultCurrencyParams{ctx, userID}
	for _, e := range mmGetDefaultCurrency.expectations {
		if minimock.Equal(e.params, mmGetDefaultCurrency.defaultExpectation.params) {
			mmGetDefaultCurrency.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetDefaultCurrency.defaultExpectation.params)
		}
	}

	return mmGetDefaultCurrency
}

// Inspect accepts an inspector function that has same arguments as the UserDB.GetDefaultCurrency
func (mmGetDefaultCurrency *mUserDBMockGetDefaultCurrency) Inspect(f func(ctx context.Context, userID int64)) *mUserDBMockGetDefaultCurrency {
	if mmGetDefaultCurrency.mock.inspectFuncGetDefaultCurrency != nil {
		mmGetDefaultCurrency.mock.t.Fatalf("Inspect function is already set for UserDBMock.GetDefaultCurrency")
	}

	mmGetDefaultCurrency.mock.inspectFuncGetDefaultCurrency = f

	return mmGetDefaultCurrency
}

// Return sets up results that will be returned by UserDB.GetDefaultCurrency
func (mmGetDefaultCurrency *mUserDBMockGetDefaultCurrency) Return(s1 string, err error) *UserDBMock {
	if mmGetDefaultCurrency.mock.funcGetDefaultCurrency != nil {
		mmGetDefaultCurrency.mock.t.Fatalf("UserDBMock.GetDefaultCurrency mock is already set by Set")
	}

	if mmGetDefaultCurrency.defaultExpectation == nil {
		mmGetDefaultCurrency.defaultExpectation = &UserDBMockGetDefaultCurrencyExpectation{mock: mmGetDefaultCurrency.mock}
	}
	mmGetDefaultCurrency.defaultExpectation.results = &UserDBMockGetDefaultCurrencyResults{s1, err}
	return mmGetDefaultCurrency.mock
}

// Set uses given function f to mock the UserDB.GetDefaultCurrency method
func (mmGetDefaultCurrency *mUserDBMockGetDefaultCurrency) Set(f func(ctx context.Context, userID int64) (s1 string, err error)) *UserDBMock {
	if mmGetDefaultCurrency.defaultExpectation != nil {
		mmGetDefaultCurrency.mock.t.Fatalf("Default expectation is already set for the UserDB.GetDefaultCurrency method")
	}

	if len(mmGetDefaultCurrency.expectations) > 0 {
		mmGetDefaultCurrency.mock.t.Fatalf("Some expectations are already set for the UserDB.GetDefaultCurrency method")
	}

	mmGetDefaultCurrency.mock.funcGetDefaultCurrency = f
	return mmGetDefaultCurrency.mock
}

// When sets expectation for the UserDB.GetDefaultCurrency which will trigger the result defined by the following
// Then helper
func (mmGetDefaultCurrency *mUserDBMockGetDefaultCurrency) When(ctx context.Context, userID int64) *UserDBMockGetDefaultCurrencyExpectation {
	if mmGetDefaultCurrency.mock.funcGetDefaultCurrency != nil {
		mmGetDefaultCurrency.mock.t.Fatalf("UserDBMock.GetDefaultCurrency mock is already set by Set")
	}

	expectation := &UserDBMockGetDefaultCurrencyExpectation{
		mock:   mmGetDefaultCurrency.mock,
		params: &UserDBMockGetDefaultCurrencyParams{ctx, userID},
	}
	mmGetDefaultCurrency.expectations = append(mmGetDefaultCurrency.expectations, expectation)
	return expectation
}

// Then sets up UserDB.GetDefaultCurrency return parameters for the expectation previously defined by the When method
func (e *UserDBMockGetDefaultCurrencyExpectation) Then(s1 string, err error) *UserDBMock {
	e.results = &UserDBMockGetDefaultCurrencyResults{s1, err}
	return e.mock
}

// GetDefaultCurrency implements messages.UserDB
func (mmGetDefaultCurrency *UserDBMock) GetDefaultCurrency(ctx context.Context, userID int64) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetDefaultCurrency.beforeGetDefaultCurrencyCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDefaultCurrency.afterGetDefaultCurrencyCounter, 1)

	if mmGetDefaultCurrency.inspectFuncGetDefaultCurrency != nil {
		mmGetDefaultCurrency.inspectFuncGetDefaultCurrency(ctx, userID)
	}

	mm_params := UserDBMockGetDefaultCurrencyParams{ctx, userID}

	// Record call args
	mmGetDefaultCurrency.GetDefaultCurrencyMock.mutex.Lock()
	mmGetDefaultCurrency.GetDefaultCurrencyMock.callArgs = append(mmGetDefaultCurrency.GetDefaultCurrencyMock.callArgs, &mm_params)
	mmGetDefaultCurrency.GetDefaultCurrencyMock.mutex.Unlock()

	for _, e := range mmGetDefaultCurrency.GetDefaultCurrencyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetDefaultCurrency.GetDefaultCurrencyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDefaultCurrency.GetDefaultCurrencyMock.defaultExpectation.Counter, 1)
		mm_want := mmGetDefaultCurrency.GetDefaultCurrencyMock.defaultExpectation.params
		mm_got := UserDBMockGetDefaultCurrencyParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetDefaultCurrency.t.Errorf("UserDBMock.GetDefaultCurrency got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetDefaultCurrency.GetDefaultCurrencyMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDefaultCurrency.t.Fatal("No results are set for the UserDBMock.GetDefaultCurrency")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetDefaultCurrency.funcGetDefaultCurrency != nil {
		return mmGetDefaultCurrency.funcGetDefaultCurrency(ctx, userID)
	}
	mmGetDefaultCurrency.t.Fatalf("Unexpected call to UserDBMock.GetDefaultCurrency. %v %v", ctx, userID)
	return
}

// GetDefaultCurrencyAfterCounter returns a count of finished UserDBMock.GetDefaultCurrency invocations
func (mmGetDefaultCurrency *UserDBMock) GetDefaultCurrencyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDefaultCurrency.afterGetDefaultCurrencyCounter)
}

// GetDefaultCurrencyBeforeCounter returns a count of UserDBMock.GetDefaultCurrency invocations
func (mmGetDefaultCurrency *UserDBMock) GetDefaultCurrencyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDefaultCurrency.beforeGetDefaultCurrencyCounter)
}

// Calls returns a list of arguments used in each call to UserDBMock.GetDefaultCurrency.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetDefaultCurrency *mUserDBMockGetDefaultCurrency) Calls() []*UserDBMockGetDefaultCurrencyParams {
	mmGetDefaultCurrency.mutex.RLock()

	argCopy := make([]*UserDBMockGetDefaultCurrencyParams, len(mmGetDefaultCurrency.callArgs))
	copy(argCopy, mmGetDefaultCurrency.callArgs)

	mmGetDefaultCurrency.mutex.RUnlock()

	return argCopy
}

// MinimockGetDefaultCurrencyDone returns true if the count of the GetDefaultCurrency invocations corresponds
// the number of defined expectations
func (m *UserDBMock) MinimockGetDefaultCurrencyDone() bool {
	for _, e := range m.GetDefaultCurrencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDefaultCurrencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDefaultCurrencyCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDefaultCurrency != nil && mm_atomic.LoadUint64(&m.afterGetDefaultCurrencyCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDefaultCurrencyInspect logs each unmet expectation
func (m *UserDBMock) MinimockGetDefaultCurrencyInspect() {
	for _, e := range m.GetDefaultCurrencyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserDBMock.GetDefaultCurrency with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDefaultCurrencyMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDefaultCurrencyCounter) < 1 {
		if m.GetDefaultCurrencyMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserDBMock.GetDefaultCurrency")
		} else {
			m.t.Errorf("Expected call to UserDBMock.GetDefaultCurrency with params: %#v", *m.GetDefaultCurrencyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDefaultCurrency != nil && mm_atomic.LoadUint64(&m.afterGetDefaultCurrencyCounter) < 1 {
		m.t.Error("Expected call to UserDBMock.GetDefaultCurrency")
	}
}

type mUserDBMockUserExists struct {
	mock               *UserDBMock
	defaultExpectation *UserDBMockUserExistsExpectation
	expectations       []*UserDBMockUserExistsExpectation

	callArgs []*UserDBMockUserExistsParams
	mutex    sync.RWMutex
}

// UserDBMockUserExistsExpectation specifies expectation struct of the UserDB.UserExists
type UserDBMockUserExistsExpectation struct {
	mock    *UserDBMock
	params  *UserDBMockUserExistsParams
	results *UserDBMockUserExistsResults
	Counter uint64
}

// UserDBMockUserExistsParams contains parameters of the UserDB.UserExists
type UserDBMockUserExistsParams struct {
	ctx    context.Context
	userID int64
}

// UserDBMockUserExistsResults contains results of the UserDB.UserExists
type UserDBMockUserExistsResults struct {
	b1 bool
}

// Expect sets up expected params for UserDB.UserExists
func (mmUserExists *mUserDBMockUserExists) Expect(ctx context.Context, userID int64) *mUserDBMockUserExists {
	if mmUserExists.mock.funcUserExists != nil {
		mmUserExists.mock.t.Fatalf("UserDBMock.UserExists mock is already set by Set")
	}

	if mmUserExists.defaultExpectation == nil {
		mmUserExists.defaultExpectation = &UserDBMockUserExistsExpectation{}
	}

	mmUserExists.defaultExpectation.params = &UserDBMockUserExistsParams{ctx, userID}
	for _, e := range mmUserExists.expectations {
		if minimock.Equal(e.params, mmUserExists.defaultExpectation.params) {
			mmUserExists.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUserExists.defaultExpectation.params)
		}
	}

	return mmUserExists
}

// Inspect accepts an inspector function that has same arguments as the UserDB.UserExists
func (mmUserExists *mUserDBMockUserExists) Inspect(f func(ctx context.Context, userID int64)) *mUserDBMockUserExists {
	if mmUserExists.mock.inspectFuncUserExists != nil {
		mmUserExists.mock.t.Fatalf("Inspect function is already set for UserDBMock.UserExists")
	}

	mmUserExists.mock.inspectFuncUserExists = f

	return mmUserExists
}

// Return sets up results that will be returned by UserDB.UserExists
func (mmUserExists *mUserDBMockUserExists) Return(b1 bool) *UserDBMock {
	if mmUserExists.mock.funcUserExists != nil {
		mmUserExists.mock.t.Fatalf("UserDBMock.UserExists mock is already set by Set")
	}

	if mmUserExists.defaultExpectation == nil {
		mmUserExists.defaultExpectation = &UserDBMockUserExistsExpectation{mock: mmUserExists.mock}
	}
	mmUserExists.defaultExpectation.results = &UserDBMockUserExistsResults{b1}
	return mmUserExists.mock
}

// Set uses given function f to mock the UserDB.UserExists method
func (mmUserExists *mUserDBMockUserExists) Set(f func(ctx context.Context, userID int64) (b1 bool)) *UserDBMock {
	if mmUserExists.defaultExpectation != nil {
		mmUserExists.mock.t.Fatalf("Default expectation is already set for the UserDB.UserExists method")
	}

	if len(mmUserExists.expectations) > 0 {
		mmUserExists.mock.t.Fatalf("Some expectations are already set for the UserDB.UserExists method")
	}

	mmUserExists.mock.funcUserExists = f
	return mmUserExists.mock
}

// When sets expectation for the UserDB.UserExists which will trigger the result defined by the following
// Then helper
func (mmUserExists *mUserDBMockUserExists) When(ctx context.Context, userID int64) *UserDBMockUserExistsExpectation {
	if mmUserExists.mock.funcUserExists != nil {
		mmUserExists.mock.t.Fatalf("UserDBMock.UserExists mock is already set by Set")
	}

	expectation := &UserDBMockUserExistsExpectation{
		mock:   mmUserExists.mock,
		params: &UserDBMockUserExistsParams{ctx, userID},
	}
	mmUserExists.expectations = append(mmUserExists.expectations, expectation)
	return expectation
}

// Then sets up UserDB.UserExists return parameters for the expectation previously defined by the When method
func (e *UserDBMockUserExistsExpectation) Then(b1 bool) *UserDBMock {
	e.results = &UserDBMockUserExistsResults{b1}
	return e.mock
}

// UserExists implements messages.UserDB
func (mmUserExists *UserDBMock) UserExists(ctx context.Context, userID int64) (b1 bool) {
	mm_atomic.AddUint64(&mmUserExists.beforeUserExistsCounter, 1)
	defer mm_atomic.AddUint64(&mmUserExists.afterUserExistsCounter, 1)

	if mmUserExists.inspectFuncUserExists != nil {
		mmUserExists.inspectFuncUserExists(ctx, userID)
	}

	mm_params := UserDBMockUserExistsParams{ctx, userID}

	// Record call args
	mmUserExists.UserExistsMock.mutex.Lock()
	mmUserExists.UserExistsMock.callArgs = append(mmUserExists.UserExistsMock.callArgs, &mm_params)
	mmUserExists.UserExistsMock.mutex.Unlock()

	for _, e := range mmUserExists.UserExistsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmUserExists.UserExistsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserExists.UserExistsMock.defaultExpectation.Counter, 1)
		mm_want := mmUserExists.UserExistsMock.defaultExpectation.params
		mm_got := UserDBMockUserExistsParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUserExists.t.Errorf("UserDBMock.UserExists got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUserExists.UserExistsMock.defaultExpectation.results
		if mm_results == nil {
			mmUserExists.t.Fatal("No results are set for the UserDBMock.UserExists")
		}
		return (*mm_results).b1
	}
	if mmUserExists.funcUserExists != nil {
		return mmUserExists.funcUserExists(ctx, userID)
	}
	mmUserExists.t.Fatalf("Unexpected call to UserDBMock.UserExists. %v %v", ctx, userID)
	return
}

// UserExistsAfterCounter returns a count of finished UserDBMock.UserExists invocations
func (mmUserExists *UserDBMock) UserExistsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserExists.afterUserExistsCounter)
}

// UserExistsBeforeCounter returns a count of UserDBMock.UserExists invocations
func (mmUserExists *UserDBMock) UserExistsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserExists.beforeUserExistsCounter)
}

// Calls returns a list of arguments used in each call to UserDBMock.UserExists.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUserExists *mUserDBMockUserExists) Calls() []*UserDBMockUserExistsParams {
	mmUserExists.mutex.RLock()

	argCopy := make([]*UserDBMockUserExistsParams, len(mmUserExists.callArgs))
	copy(argCopy, mmUserExists.callArgs)

	mmUserExists.mutex.RUnlock()

	return argCopy
}

// MinimockUserExistsDone returns true if the count of the UserExists invocations corresponds
// the number of defined expectations
func (m *UserDBMock) MinimockUserExistsDone() bool {
	for _, e := range m.UserExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UserExistsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUserExistsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserExists != nil && mm_atomic.LoadUint64(&m.afterUserExistsCounter) < 1 {
		return false
	}
	return true
}

// MinimockUserExistsInspect logs each unmet expectation
func (m *UserDBMock) MinimockUserExistsInspect() {
	for _, e := range m.UserExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserDBMock.UserExists with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UserExistsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUserExistsCounter) < 1 {
		if m.UserExistsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to UserDBMock.UserExists")
		} else {
			m.t.Errorf("Expected call to UserDBMock.UserExists with params: %#v", *m.UserExistsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserExists != nil && mm_atomic.LoadUint64(&m.afterUserExistsCounter) < 1 {
		m.t.Error("Expected call to UserDBMock.UserExists")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserDBMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockChangeDefaultCurrencyInspect()

			m.MinimockGetDefaultCurrencyInspect()

			m.MinimockUserExistsInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserDBMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserDBMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockChangeDefaultCurrencyDone() &&
		m.MinimockGetDefaultCurrencyDone() &&
		m.MinimockUserExistsDone()
}
