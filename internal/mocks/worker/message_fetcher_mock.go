// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package worker

//go:generate minimock -i github.com/Svoevolin/workshop_1_bot/internal/worker.MessageFetcher -o message_fetcher_mock.go -n MessageFetcherMock -p worker

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"github.com/gojuno/minimock/v3"
)

// MessageFetcherMock implements worker.MessageFetcher
type MessageFetcherMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcRequest          func(callback tgbotapi.CallbackConfig) (err error)
	inspectFuncRequest   func(callback tgbotapi.CallbackConfig)
	afterRequestCounter  uint64
	beforeRequestCounter uint64
	RequestMock          mMessageFetcherMockRequest

	funcStart          func() (u1 tgbotapi.UpdatesChannel)
	inspectFuncStart   func()
	afterStartCounter  uint64
	beforeStartCounter uint64
	StartMock          mMessageFetcherMockStart

	funcStop          func()
	inspectFuncStop   func()
	afterStopCounter  uint64
	beforeStopCounter uint64
	StopMock          mMessageFetcherMockStop
}

// NewMessageFetcherMock returns a mock for worker.MessageFetcher
func NewMessageFetcherMock(t minimock.Tester) *MessageFetcherMock {
	m := &MessageFetcherMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.RequestMock = mMessageFetcherMockRequest{mock: m}
	m.RequestMock.callArgs = []*MessageFetcherMockRequestParams{}

	m.StartMock = mMessageFetcherMockStart{mock: m}

	m.StopMock = mMessageFetcherMockStop{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mMessageFetcherMockRequest struct {
	mock               *MessageFetcherMock
	defaultExpectation *MessageFetcherMockRequestExpectation
	expectations       []*MessageFetcherMockRequestExpectation

	callArgs []*MessageFetcherMockRequestParams
	mutex    sync.RWMutex
}

// MessageFetcherMockRequestExpectation specifies expectation struct of the MessageFetcher.Request
type MessageFetcherMockRequestExpectation struct {
	mock    *MessageFetcherMock
	params  *MessageFetcherMockRequestParams
	results *MessageFetcherMockRequestResults
	Counter uint64
}

// MessageFetcherMockRequestParams contains parameters of the MessageFetcher.Request
type MessageFetcherMockRequestParams struct {
	callback tgbotapi.CallbackConfig
}

// MessageFetcherMockRequestResults contains results of the MessageFetcher.Request
type MessageFetcherMockRequestResults struct {
	err error
}

// Expect sets up expected params for MessageFetcher.Request
func (mmRequest *mMessageFetcherMockRequest) Expect(callback tgbotapi.CallbackConfig) *mMessageFetcherMockRequest {
	if mmRequest.mock.funcRequest != nil {
		mmRequest.mock.t.Fatalf("MessageFetcherMock.Request mock is already set by Set")
	}

	if mmRequest.defaultExpectation == nil {
		mmRequest.defaultExpectation = &MessageFetcherMockRequestExpectation{}
	}

	mmRequest.defaultExpectation.params = &MessageFetcherMockRequestParams{callback}
	for _, e := range mmRequest.expectations {
		if minimock.Equal(e.params, mmRequest.defaultExpectation.params) {
			mmRequest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRequest.defaultExpectation.params)
		}
	}

	return mmRequest
}

// Inspect accepts an inspector function that has same arguments as the MessageFetcher.Request
func (mmRequest *mMessageFetcherMockRequest) Inspect(f func(callback tgbotapi.CallbackConfig)) *mMessageFetcherMockRequest {
	if mmRequest.mock.inspectFuncRequest != nil {
		mmRequest.mock.t.Fatalf("Inspect function is already set for MessageFetcherMock.Request")
	}

	mmRequest.mock.inspectFuncRequest = f

	return mmRequest
}

// Return sets up results that will be returned by MessageFetcher.Request
func (mmRequest *mMessageFetcherMockRequest) Return(err error) *MessageFetcherMock {
	if mmRequest.mock.funcRequest != nil {
		mmRequest.mock.t.Fatalf("MessageFetcherMock.Request mock is already set by Set")
	}

	if mmRequest.defaultExpectation == nil {
		mmRequest.defaultExpectation = &MessageFetcherMockRequestExpectation{mock: mmRequest.mock}
	}
	mmRequest.defaultExpectation.results = &MessageFetcherMockRequestResults{err}
	return mmRequest.mock
}

// Set uses given function f to mock the MessageFetcher.Request method
func (mmRequest *mMessageFetcherMockRequest) Set(f func(callback tgbotapi.CallbackConfig) (err error)) *MessageFetcherMock {
	if mmRequest.defaultExpectation != nil {
		mmRequest.mock.t.Fatalf("Default expectation is already set for the MessageFetcher.Request method")
	}

	if len(mmRequest.expectations) > 0 {
		mmRequest.mock.t.Fatalf("Some expectations are already set for the MessageFetcher.Request method")
	}

	mmRequest.mock.funcRequest = f
	return mmRequest.mock
}

// When sets expectation for the MessageFetcher.Request which will trigger the result defined by the following
// Then helper
func (mmRequest *mMessageFetcherMockRequest) When(callback tgbotapi.CallbackConfig) *MessageFetcherMockRequestExpectation {
	if mmRequest.mock.funcRequest != nil {
		mmRequest.mock.t.Fatalf("MessageFetcherMock.Request mock is already set by Set")
	}

	expectation := &MessageFetcherMockRequestExpectation{
		mock:   mmRequest.mock,
		params: &MessageFetcherMockRequestParams{callback},
	}
	mmRequest.expectations = append(mmRequest.expectations, expectation)
	return expectation
}

// Then sets up MessageFetcher.Request return parameters for the expectation previously defined by the When method
func (e *MessageFetcherMockRequestExpectation) Then(err error) *MessageFetcherMock {
	e.results = &MessageFetcherMockRequestResults{err}
	return e.mock
}

// Request implements worker.MessageFetcher
func (mmRequest *MessageFetcherMock) Request(callback tgbotapi.CallbackConfig) (err error) {
	mm_atomic.AddUint64(&mmRequest.beforeRequestCounter, 1)
	defer mm_atomic.AddUint64(&mmRequest.afterRequestCounter, 1)

	if mmRequest.inspectFuncRequest != nil {
		mmRequest.inspectFuncRequest(callback)
	}

	mm_params := MessageFetcherMockRequestParams{callback}

	// Record call args
	mmRequest.RequestMock.mutex.Lock()
	mmRequest.RequestMock.callArgs = append(mmRequest.RequestMock.callArgs, &mm_params)
	mmRequest.RequestMock.mutex.Unlock()

	for _, e := range mmRequest.RequestMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRequest.RequestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRequest.RequestMock.defaultExpectation.Counter, 1)
		mm_want := mmRequest.RequestMock.defaultExpectation.params
		mm_got := MessageFetcherMockRequestParams{callback}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRequest.t.Errorf("MessageFetcherMock.Request got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRequest.RequestMock.defaultExpectation.results
		if mm_results == nil {
			mmRequest.t.Fatal("No results are set for the MessageFetcherMock.Request")
		}
		return (*mm_results).err
	}
	if mmRequest.funcRequest != nil {
		return mmRequest.funcRequest(callback)
	}
	mmRequest.t.Fatalf("Unexpected call to MessageFetcherMock.Request. %v", callback)
	return
}

// RequestAfterCounter returns a count of finished MessageFetcherMock.Request invocations
func (mmRequest *MessageFetcherMock) RequestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRequest.afterRequestCounter)
}

// RequestBeforeCounter returns a count of MessageFetcherMock.Request invocations
func (mmRequest *MessageFetcherMock) RequestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRequest.beforeRequestCounter)
}

// Calls returns a list of arguments used in each call to MessageFetcherMock.Request.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRequest *mMessageFetcherMockRequest) Calls() []*MessageFetcherMockRequestParams {
	mmRequest.mutex.RLock()

	argCopy := make([]*MessageFetcherMockRequestParams, len(mmRequest.callArgs))
	copy(argCopy, mmRequest.callArgs)

	mmRequest.mutex.RUnlock()

	return argCopy
}

// MinimockRequestDone returns true if the count of the Request invocations corresponds
// the number of defined expectations
func (m *MessageFetcherMock) MinimockRequestDone() bool {
	for _, e := range m.RequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRequestCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRequest != nil && mm_atomic.LoadUint64(&m.afterRequestCounter) < 1 {
		return false
	}
	return true
}

// MinimockRequestInspect logs each unmet expectation
func (m *MessageFetcherMock) MinimockRequestInspect() {
	for _, e := range m.RequestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessageFetcherMock.Request with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RequestMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRequestCounter) < 1 {
		if m.RequestMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessageFetcherMock.Request")
		} else {
			m.t.Errorf("Expected call to MessageFetcherMock.Request with params: %#v", *m.RequestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRequest != nil && mm_atomic.LoadUint64(&m.afterRequestCounter) < 1 {
		m.t.Error("Expected call to MessageFetcherMock.Request")
	}
}

type mMessageFetcherMockStart struct {
	mock               *MessageFetcherMock
	defaultExpectation *MessageFetcherMockStartExpectation
	expectations       []*MessageFetcherMockStartExpectation
}

// MessageFetcherMockStartExpectation specifies expectation struct of the MessageFetcher.Start
type MessageFetcherMockStartExpectation struct {
	mock *MessageFetcherMock

	results *MessageFetcherMockStartResults
	Counter uint64
}

// MessageFetcherMockStartResults contains results of the MessageFetcher.Start
type MessageFetcherMockStartResults struct {
	u1 tgbotapi.UpdatesChannel
}

// Expect sets up expected params for MessageFetcher.Start
func (mmStart *mMessageFetcherMockStart) Expect() *mMessageFetcherMockStart {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("MessageFetcherMock.Start mock is already set by Set")
	}

	if mmStart.defaultExpectation == nil {
		mmStart.defaultExpectation = &MessageFetcherMockStartExpectation{}
	}

	return mmStart
}

// Inspect accepts an inspector function that has same arguments as the MessageFetcher.Start
func (mmStart *mMessageFetcherMockStart) Inspect(f func()) *mMessageFetcherMockStart {
	if mmStart.mock.inspectFuncStart != nil {
		mmStart.mock.t.Fatalf("Inspect function is already set for MessageFetcherMock.Start")
	}

	mmStart.mock.inspectFuncStart = f

	return mmStart
}

// Return sets up results that will be returned by MessageFetcher.Start
func (mmStart *mMessageFetcherMockStart) Return(u1 tgbotapi.UpdatesChannel) *MessageFetcherMock {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("MessageFetcherMock.Start mock is already set by Set")
	}

	if mmStart.defaultExpectation == nil {
		mmStart.defaultExpectation = &MessageFetcherMockStartExpectation{mock: mmStart.mock}
	}
	mmStart.defaultExpectation.results = &MessageFetcherMockStartResults{u1}
	return mmStart.mock
}

// Set uses given function f to mock the MessageFetcher.Start method
func (mmStart *mMessageFetcherMockStart) Set(f func() (u1 tgbotapi.UpdatesChannel)) *MessageFetcherMock {
	if mmStart.defaultExpectation != nil {
		mmStart.mock.t.Fatalf("Default expectation is already set for the MessageFetcher.Start method")
	}

	if len(mmStart.expectations) > 0 {
		mmStart.mock.t.Fatalf("Some expectations are already set for the MessageFetcher.Start method")
	}

	mmStart.mock.funcStart = f
	return mmStart.mock
}

// Start implements worker.MessageFetcher
func (mmStart *MessageFetcherMock) Start() (u1 tgbotapi.UpdatesChannel) {
	mm_atomic.AddUint64(&mmStart.beforeStartCounter, 1)
	defer mm_atomic.AddUint64(&mmStart.afterStartCounter, 1)

	if mmStart.inspectFuncStart != nil {
		mmStart.inspectFuncStart()
	}

	if mmStart.StartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStart.StartMock.defaultExpectation.Counter, 1)

		mm_results := mmStart.StartMock.defaultExpectation.results
		if mm_results == nil {
			mmStart.t.Fatal("No results are set for the MessageFetcherMock.Start")
		}
		return (*mm_results).u1
	}
	if mmStart.funcStart != nil {
		return mmStart.funcStart()
	}
	mmStart.t.Fatalf("Unexpected call to MessageFetcherMock.Start.")
	return
}

// StartAfterCounter returns a count of finished MessageFetcherMock.Start invocations
func (mmStart *MessageFetcherMock) StartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStart.afterStartCounter)
}

// StartBeforeCounter returns a count of MessageFetcherMock.Start invocations
func (mmStart *MessageFetcherMock) StartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStart.beforeStartCounter)
}

// MinimockStartDone returns true if the count of the Start invocations corresponds
// the number of defined expectations
func (m *MessageFetcherMock) MinimockStartDone() bool {
	for _, e := range m.StartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStart != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		return false
	}
	return true
}

// MinimockStartInspect logs each unmet expectation
func (m *MessageFetcherMock) MinimockStartInspect() {
	for _, e := range m.StartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MessageFetcherMock.Start")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		m.t.Error("Expected call to MessageFetcherMock.Start")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStart != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		m.t.Error("Expected call to MessageFetcherMock.Start")
	}
}

type mMessageFetcherMockStop struct {
	mock               *MessageFetcherMock
	defaultExpectation *MessageFetcherMockStopExpectation
	expectations       []*MessageFetcherMockStopExpectation
}

// MessageFetcherMockStopExpectation specifies expectation struct of the MessageFetcher.Stop
type MessageFetcherMockStopExpectation struct {
	mock *MessageFetcherMock

	Counter uint64
}

// Expect sets up expected params for MessageFetcher.Stop
func (mmStop *mMessageFetcherMockStop) Expect() *mMessageFetcherMockStop {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("MessageFetcherMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &MessageFetcherMockStopExpectation{}
	}

	return mmStop
}

// Inspect accepts an inspector function that has same arguments as the MessageFetcher.Stop
func (mmStop *mMessageFetcherMockStop) Inspect(f func()) *mMessageFetcherMockStop {
	if mmStop.mock.inspectFuncStop != nil {
		mmStop.mock.t.Fatalf("Inspect function is already set for MessageFetcherMock.Stop")
	}

	mmStop.mock.inspectFuncStop = f

	return mmStop
}

// Return sets up results that will be returned by MessageFetcher.Stop
func (mmStop *mMessageFetcherMockStop) Return() *MessageFetcherMock {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("MessageFetcherMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &MessageFetcherMockStopExpectation{mock: mmStop.mock}
	}

	return mmStop.mock
}

// Set uses given function f to mock the MessageFetcher.Stop method
func (mmStop *mMessageFetcherMockStop) Set(f func()) *MessageFetcherMock {
	if mmStop.defaultExpectation != nil {
		mmStop.mock.t.Fatalf("Default expectation is already set for the MessageFetcher.Stop method")
	}

	if len(mmStop.expectations) > 0 {
		mmStop.mock.t.Fatalf("Some expectations are already set for the MessageFetcher.Stop method")
	}

	mmStop.mock.funcStop = f
	return mmStop.mock
}

// Stop implements worker.MessageFetcher
func (mmStop *MessageFetcherMock) Stop() {
	mm_atomic.AddUint64(&mmStop.beforeStopCounter, 1)
	defer mm_atomic.AddUint64(&mmStop.afterStopCounter, 1)

	if mmStop.inspectFuncStop != nil {
		mmStop.inspectFuncStop()
	}

	if mmStop.StopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStop.StopMock.defaultExpectation.Counter, 1)

		return

	}
	if mmStop.funcStop != nil {
		mmStop.funcStop()
		return
	}
	mmStop.t.Fatalf("Unexpected call to MessageFetcherMock.Stop.")

}

// StopAfterCounter returns a count of finished MessageFetcherMock.Stop invocations
func (mmStop *MessageFetcherMock) StopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.afterStopCounter)
}

// StopBeforeCounter returns a count of MessageFetcherMock.Stop invocations
func (mmStop *MessageFetcherMock) StopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.beforeStopCounter)
}

// MinimockStopDone returns true if the count of the Stop invocations corresponds
// the number of defined expectations
func (m *MessageFetcherMock) MinimockStopDone() bool {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	return true
}

// MinimockStopInspect logs each unmet expectation
func (m *MessageFetcherMock) MinimockStopInspect() {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MessageFetcherMock.Stop")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		m.t.Error("Expected call to MessageFetcherMock.Stop")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		m.t.Error("Expected call to MessageFetcherMock.Stop")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MessageFetcherMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockRequestInspect()

			m.MinimockStartInspect()

			m.MinimockStopInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MessageFetcherMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MessageFetcherMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockRequestDone() &&
		m.MinimockStartDone() &&
		m.MinimockStopDone()
}
